Important Warnings
Workspace Deletion vs. Resource Destruction: Running terraform workspace delete <name> does not destroy the resources; it only deletes the state file. The resources will become "dangling" and must be deleted manually in your cloud console.
State Locking: If using a remote backend with state locking, ensure no other processes are running in those workspaces, or the script will fail.

deleting resource 

for ws in $(terraform workspace list | grep -v '*' | grep -v default | tr -d ' '); do
  echo "Switching to workspace: $ws"
  terraform workspace select "$ws"
 echo "yes" |  terraform destroy
done



./case_workspace.sh <workspace> <plan|apply|destroy>
set -e

WORKSPACE=$1
ACTION=$2

# Validate inputs
if [[ -z "$WORKSPACE" || -z "$ACTION" ]]; then
  echo "Usage: $0 <workspace_name> <apply|destroy|plan>"
  exit 1
fi

# Ensure Terraform is initialized
terraform init -input=false

# Workspace "Select or Create" logic
echo "--- Targeting Workspace: $WORKSPACE ---"
terraform workspace select "$WORKSPACE" 2>/dev/null || terraform workspace new "$WORKSPACE"

# Execute logic based on action
case "$ACTION" in
  plan)
    echo "Generating plan for $WORKSPACE..."
    terraform plan -var-file="terraform.tfstate.d/${WORKSPACE}/${WORKSPACE}.tfvars"
    ;;

  apply)
    echo "Applying infrastructure changes for $WORKSPACE..."
    terraform apply -var-file="terraform.tfstate.d/${WORKSPACE}/${WORKSPACE}.tfvars" -auto-approve
    ;;

  destroy)
    echo "WARNING: Destroying all resources in $WORKSPACE..."
    terraform destroy -var-file="terraform.tfstate.d/${WORKSPACE}/${WORKSPACE}.tfvars" -auto-approve
    
    # Cleanup: Switch back to default to allow workspace deletion
    terraform workspace select default
   # terraform workspace delete "$WORKSPACE"
    echo "Workspace $WORKSPACE has been removed."
    ;;

  *)
    echo "Error: Invalid action '$ACTION'. Use: plan, apply, or destroy."
    exit 1
    ;;
esac


3. Key Best Practices for Scripts

Variable Files: Name your .tfvars files after your workspaces (e.g., dev.tfvars, prod.tfvars) so the script can dynamically load them using -var-file="envs/${WORKSPACE}.tfvars".

Non-Interactive Mode: Use the -input=false and -auto-approve flags to ensure the script doesn't hang waiting for user confirmation.

Safety Guards: In your Terraform configuration, use a null_resource or lifecycle block to prevent accidental runs in the default workspace.
Remote State: Always use a remote backend (like S3 or HCP Terraform) for automated scripts to ensure state is shared and locked during runs.
Key Logic Improvements:

The plan Case: Added a Terraform Plan option, which is standard practice before running an apply in automation.

Default Handling: The *) case catches typos and prevents the script from running with invalid commands.

Automatic Deletion: In the destroy case, it automatically performs the Workspace Delete after the resources are gone, which keeps your environment list clean.

Silence Errors: Used 2>/dev/null on the select command so you don't see a "workspace not found" error message when the script creates a new one for the first time.

Pro-Tip: If you are running this in a CI/CD environment like Jenkins or GitLab CI, ensure your envs/ directory is checked into your repository.
