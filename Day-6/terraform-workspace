Terraform workspaces are designed to manage multiple environments efficiently within a single Terraform project. This approach eliminates the need for redundant configurations for different environments, streamlining the process significantly
Using Terraform workspaces allows for the efficient management of multiple environments without the need to rewrite configuration files for each one. This approach ensures that state files remain distinct and do not conflict, simplifying infrastructure management.
Using Terraform workspaces is essential for managing multiple environments like development, staging, and production effectively. This approach prevents interference between different infrastructure states, ensuring smooth operation.
Terraform workspaces simplify infrastructure management by allowing different configurations for various environments without altering existing resources. They enhance efficiency, especially when handling complex infrastructure setups.
Understanding how to use Terraform workspaces is crucial for managing different environments. Properly setting instance types and defaults can significantly impact your infrastructure deployment.
Terraform workspaces allow you to manage multiple sets of infrastructure state within a single configuration. The primary command for this is terraform workspace, which acts as a container for several subcommands. 
Core Workspace Subcommands
terraform workspace list: Displays all available workspaces in the current backend. The active workspace is marked with an asterisk (*).
terraform workspace show: Prints the name of the currently selected workspace.
terraform workspace new <name>: Creates a new workspace with the specified name and automatically switches to it.
Note: If using a local backend, this creates a state file in the terraform.tfstate.d/<name>/ directory.
terraform workspace select <name>: Switches to an existing workspace. Use the -or-create flag to create it if it doesn't already exist.
terraform workspace delete <name>: Removes an existing workspace.
Restriction: You cannot delete the default workspace or the currently active workspace.
Force: Use the -force flag to delete a workspace that still contains infrastructure resources (this will result in "dangling" resources that Terraform no longer manages). 

Common Usage & Tips
Interpolation: You can reference the current workspace name in your configuration using the ${terraform.workspace} variable to dynamically set resource names, tags, or regions.
Isolation: Each workspace has its own independent Terraform state. Running terraform apply in one workspace will not affect the infrastructure of another.
Remote Backends: In HCP Terraform (formerly Terraform Cloud), workspaces are more advanced and can be linked to VCS repositories or used with a workspace prefix in the backend configuration.

To use environment-specific variables with workspaces, you typically use the ${terraform.workspace} interpolation to select values from a map or to load external files.
1. The Map-Based Lookup (In-Code)
This is the simplest method for managing a few differences (like instance sizes) directly in your configuration

variable "instance_sizes" {
  type = map(string)
  default = {
    default = "t3.nano"
    dev     = "t3.micro"
    prod    = "m5.large"
  }
}

resource "aws_instance" "web" {
  # Selects size based on the active workspace name
  instance_type = var.instance_sizes[terraform.workspace]
  
  tags = {
    Name = "server-${terraform.workspace}"
  }
}

2. Workspace-Specific .tfvars Files (Best Practice) 
For complex environments, use separate variable definition files named after your workspaces.

File Structure:
envs/dev.tfvars
envs/prod.tfvars
Execution:
When running commands, manually specify the file that matches your workspace:

terraform workspace select dev
terraform apply -var-file="envs/dev.tfvars"

3. Using Locals for Complex Logic
If you need to merge default settings with environment-specific overrides, use Local Values.

locals {
  env_configs = {
    dev = {
      count = 1
      tier  = "Standard"
    }
    prod = {
      count = 5
      tier  = "Premium"
    }
  }

  # Fallback to dev if workspace isn't found in the map
  current_config = lookup(local.env_configs, terraform.workspace, local.env_configs.dev)
}

resource "example_resource" "main" {
  instance_count = local.current_config.count
}

Comparison of Methods
Method 
Map Lookup	
Simple projects	
No extra files; easy to read.	
Hardcoded values in .tf files.

.tfvars Files	
Production-grade infra	
Clean separation of config and code.	
Requires manual -var-file flag.

Local Logic	
Complex defaults	
High flexibility; handles fallbacks.	
Can become hard to debug if too nested.

